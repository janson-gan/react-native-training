# Learning Journal 24th May 2022
## Day 29-33: Tracker App - (continue from 23rd May 2022)
### What I Learnt Today
#### 1. Understanding Password Hashing
- To prevent password from being display in plain text in database, we can use [**Hashing Algorithm**](https://crosstower.com/resources/education/what-is-a-hashing-algorithm-and-how-does-it-work/).
- Password (string) -> Hashing Algorithm (MD5) -> Output (some string of mixing characters).
- To prevent password attack like hash table, [**Salt**](https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/) is added to the hashing process to force their uniqueness and increase complexity.
#### 2. Salting and Hashing
- In index.js, declare a Mongoose middleware 'Pre Save hook' to run a user password hashing check before send to database.
- If user password is plain text, then generate the salt and hash together and send it to database.
- The number '10' refer to the the rounds of [salting](https://heynode.com/blog/2020-04/salt-and-hash-passwords-bcrypt/). The higher the number the more time the hashing algorithm takes.
```javascript
//pre save hook, function run before saving user data to database
//using 'function' keyword because need to use 'this' keyword to reference to user
userSchema.pre('save', function(next) {
    const user = this;
    //check user password not modified (in plain text)
    if (!user.isModified('password')) {
        return next();
    }
    //to generate salt, pass in the number of salt rounds
    //pass in an error callback and salt function
    bycrypt.genSalt(10, (err, salt) => {
        //if there is an error, stop doing anything and return next with error message
        if (err) {
            return next(err);
          }
    //if no error, hash the password
    bycrypt.hash(user.password, salt, (err, hash) => {
        //if there is an error, stop doing anything and return to next with error message
        if (err) {
            return next(err);
        }
        //otherwise update the user password with hash
        user.password = hash;
        next();
        });
    });
});
```
#### Comparing the hash password.
- Use 'useSchema' property to compare the user hash password.
- <code>userSchema.methods.comparePassword</code>
- Assign a function to it and pass in the parameter of user password that use for login.
- Inside the function, return a new Promise callback with 'resolve' and 'reject' function so we can make use of async and await whenever comparing a password.
- Inside the Promise function, we use bycrypt.compare to perform the password comparison.
```javascript
userSchema.methods.comparePassword = function (userPassword) {
    //refer to the the user
    const user = this;
    //create a new promises and pass in resolve and reject parameters
    //if codes run successfully inside the promise, invoked resolve the promise, otherwise reject the promise
    //With promise we can make use of async and await whenever comparing a password
    return new Promise((resolve, reject) => {
        //using bycrypt library for comparison
        //compare between login password and database password
        bycrypt.compare(userPassword, user.password, (err, isMatch) => {
            //if error, reject the promise with error message
            if (err) {
                return reject(err);
            }
            //if password is not the same, reject return false not match
            if (!isMatch) {
                return reject(false);
            }
            //other pass validation
            resolve(true);
        });
    });
};
```
#### The Signing Route
- In authRoutes.js, add a new post request handler.
- Destructure email and password from request body.
- Validate if user provide any email or password during login. if none provided, return a status code of 422 (Unprocessable Entity) with error message.
- If user login pass validation, find the user email in database. If no email is found, return a status code with error message.
- If user email found, then compare the hash password.
- Create a json token and send back to user for future authentication if pass validation with no errors.
```javascript
/user sign in route with authentication
router.post('/signin',async (req, res) => {
    //destructuring the request body with user email and password
    const { email, password } = req.body;
    //validate user to provide email and password when sign in
    //if no email or password return a status code and error message
    if (!email || !password) {
        return res.status(422).send({ error: 'Please provide email and password to proceed.' });
    };
    //if pass the vaildation, find the user email in database
    //using await because 'findOne' take some times to search for user email
    const user = await User.findOne({ email });
    //if no email is found in database, return status code with error message
    if (!user) {
        return res.status(422).send({ error: 'Invalid email or password. Please try again.' });
    }
    //if user pass validation, compare the hash password
    //Use try and catch error handling if there's an error
    try {
    await user.comparePassword(password);
    //Pass comparison of password, create a token and send back to user for future authenticaton
    const token = jwt.sign({ userId: user._id }, 'My_SECRET_KEY');
    res.send({ token });
    } catch(err) {
        return res.status(422).send({ error: 'Invalid email or password. Please try again.' })
    }
```
#### Testing Signup and Signin
- Signup
<img src="https://github.com/janson-gan/react-native-training/blob/main/images/May-24-2022%2013-20-02.gif" width="500" />

- Signin
<img src="https://github.com/janson-gan/react-native-training/blob/main/images/May-24-2022%2013-23-39.gif" width="500" />

- Wrong Password
<img src="https://github.com/janson-gan/react-native-training/blob/main/images/May-24-2022%2013-24-53.gif" width="500" />

- No Email and Password
<img src="" width="500" />
